<script type="text/javascript" src="https://npmcdn.com/vexflow/releases/vexflow-debug.js"></script>
<body>
	<p style = "background-color:#111111">
	这是一个四线谱：
	<span class = "YMusic" fillcolor = "#DDDDDD" backfillcolor = "#000000">
		【吉他 ， 4 ， 8 ， 4】 【 3-2 、 4-3 [4] | 3-2 、 4-3 [8] |3-2 、 4-3 [8]】
	</span>
	<span class = "YMusic" fillcolor = "#DDDDDD" backfillcolor = "#000000">
		【吉他 ， 4 ， 8 ， 1】 【 3-2 、 4-3 [8]】
	</span>


</p>
	<p style = "background-color:#FFEEEE">这是一个五线谱：
		<span class = "YMusic" >
		【高，5--，4，6】【
			C/5、文：啊啊啊：2      [8] | 
			B/4 [8r] | 
			C/4       [4] | 
			A/4       [2] |
			A/4       [2] |
		】
		</span>
	</p>

<p style = "background-color:#EEEEEE">	<span class = "YMusic">
		【吉他 ， 4--， 4 ， 4】 【 
			3-x 、 4-3 、文：哈哈哈：2 [2] |
			2-3 、 4-3 [8] | 
			2-3 、 4-3 [8] | 
			2-3 、 4-3 [8] |
			2-3 、 4-3 [8] |
		】
	</span>
</p>
</body>


<script>

function ymusic_GetStaveClefType(clef){

	var stave_type = undefined
	var clef_type  = undefined

	if(clef == "高")
	{
		stave_type = "五线"
		clef_type  = "treble"
	}
	else if (clef == "吉他")
	{
		stave_type = "吉他"
		clef_type  = "tab"
	}
	else
	{
		throw "不支持的谱号！"
	}

	return [stave_type , clef_type]

}

function ymusic_AutoHeight(height , stave_type , num_lines){
	if(height != "auto")
		return parseInt(height)

	if (stave_type == "五线")
		return 10 * num_lines

	if (stave_type == "吉他")
		return 15 * num_lines

	throw "错误！"
}

function ymusic_AutoTopBotspace(stave_type){ //根据谱的类型不同自动决策上下额外加多少条线

	if (stave_type == "五线")
		return [2,2]

	if (stave_type == "吉他")
		return [1,1]

	throw "错误！"

}

function ymusic_parse_notes(note_info , metas){
	var VF = Vex.Flow

	var parsed_notes = []
	var parsed_texts = []

	var notes = note_info.trim()
	notes = notes.split("|")
	for(var note of notes){
		note = note.trim()
		if(note == "") //允许空串
			continue
		note = note.match(/([\s\S]*?)\[([\dr]*)\]/)

		// 获得长度
		var duration = note[2].trim()

		// 获得音符
		var keys = note[1].trim()
		var parsed_note_keys = [] // 对于五线谱是keys，对于吉他谱是positions
		var parsed_text 	 = "" // 所有文本
		var parsed_text_pos = -1 
		keys = keys.split("、")
		for(var key of keys){
			key = key.trim()

			if(key.startsWith("文")){ 					//是一个文本音符
				key = key.split("：")
				var text = key[1]
				parsed_text += text

				if(key.length > 2){
					posi = parseInt(key[2])
					parsed_text_pos = posi //覆盖之前的，所有文本只能有一个高度
				}
			}
			else{										//是一个正常音符
				if(metas.stave_type == "五线"){ 	//五线谱音符
					parsed_note_keys.push(key)
				}
				if(metas.stave_type == "吉他"){ 	//吉他音符
					key = key.split("-")
					var str  = parseInt(key[0].trim())  // 弦数
					var fret = key[1].trim() 			// 品数

					parsed_note_keys.push({str:str , fret:fret})
				}
			}
		}

		parsed_notes.push({duration: duration , keys: parsed_note_keys })
		parsed_texts.push({duration: duration , text: parsed_text , posi: parsed_text_pos})
	}

	return [ parsed_notes , parsed_texts ]
}


function ymusic_parse_meta(meta_info , height , width , renderer){
	var VF = Vex.Flow

	// 获取元信息
	meta_info 		= meta_info.trim().split("，")
	var clef 	   	= meta_info[0].trim() //谱号
	var beat_value 	= parseInt( meta_info[2].trim() ) //时值
	var beat_num   	= parseInt( meta_info[3].trim() ) //拍数
													  // 类型
	var [stave_type , clef_type] = ymusic_GetStaveClefType(clef)
													  //线数
	var num_lines = meta_info[1].trim()
	var [extra_topspace , extra_botspace] = ymusic_AutoTopBotspace(stave_type)
	extra_botspace -= 1 //好像Vexflow默认会在下面加一个，去掉之
	while(num_lines.endsWith("+") || num_lines.endsWith("-")){// 检查末尾有多少个加减号
		if(num_lines.endsWith("+")) //加号增加下方行数
			extra_botspace += 1
		if(num_lines.endsWith("-")) //减号增加上方行数
			extra_topspace += 1
		num_lines = num_lines.substr(0,num_lines.length-1) //去掉这个加减号
	}
	num_lines = parseInt(num_lines) //把去掉加减号之后的部分转成数字

	//计算宽高
	if(width == "auto")
		width = 30 + 300 * (beat_num / beat_value)
	height = ymusic_AutoHeight(height , stave_type , num_lines + extra_botspace + extra_topspace)


	return {
		"stave_type" : stave_type ,
		"clef_type"  : clef_type , 
		"num_lines"  : num_lines , 

		"beat_value" : beat_value ,
		"beat_num"   : beat_num ,  

		"topspace"   : extra_topspace , 
		"botspace"   : extra_botspace , 
		"height"     : height , 
		"width"    	 : width , 
	}
}

function ymusic_draw_music(element , width , height , fillcolor , backfillcolor) {
	var VF = Vex.Flow

	var render_container = document.createElement("span") //在这个新建的span内画图
	var renderer = new VF.Renderer(render_container, VF.Renderer.Backends.SVG)
	var context = renderer.getContext()
	context.setFillStyle(fillcolor).setStrokeStyle(fillcolor)
	context.setBackgroundFillStyle(backfillcolor)

	// ---------- 第一步解析 ----------
	var content = element.innerText.trim().match(/【([\S\s]*?)】\s*【([\S\s]*?)】/)
	var meta_info = content[1] // 元信息部分
	var note_info = content[2] //音符信息部分

	// ---------- 画谱 ----------

	//解析谱信息
	var metas = ymusic_parse_meta(meta_info , height , width , renderer)
	
	renderer.resize(metas.width , metas.height) //必须在创建stave之前resize

	// 创建stave
	stave = undefined
	if(metas.stave_type == "五线"){
		stave = new VF.Stave(0, 0, metas.width, {num_lines : metas.num_lines})
		stave.addClef(metas.clef_type)
		stave.addTimeSignature(metas.beat_num + "/" + metas.beat_value)
	}
	if (metas.stave_type == "吉他"){
		console.log()
		stave = new VF.TabStave(0, 0, metas.width, {num_lines : metas.num_lines})
		stave.addClef(metas.clef_type)
	}
	stave.options.space_above_staff_ln = metas.topspace //上方预留的空间
	stave.options.space_below_staff_ln = metas.botspace // 下方预留的空间
	stave.setContext(context).draw()

	// ---------- 画音符 ----------

	//解析音符信息
	var [ parsed_notes , parsed_texts ] = ymusic_parse_notes(note_info , metas)

	//画音符
	var notes_to_render = []
	for(var nt of parsed_notes){ //取出所有解析出的音符信息，转成VF音符
		if(metas.stave_type == "五线"){
			notes_to_render.push(new VF.StaveNote({
				clef 	: metas.clef_type, 
				keys 	: nt.keys, 
				duration: nt.duration,
			}))
		}
		if(metas.stave_type == "吉他"){
			notes_to_render.push(new VF.TabNote({
				positions 	: nt.keys, 
				duration 	: nt.duration,
			}))
		}
	}
	var texts_to_render = []
	for(var nt of parsed_texts){ //取出所有文本信息，转成TextNote

		texts_to_render.push(
			new VF.TextNote({
				font: {
					family: "Arial",
					size: 12,
					weight: ""
				},
				text 	: nt.text + " ", 
				duration: nt.duration,
			})
			.setLine(nt.posi+3)
			.setStave(stave)
			.setJustification(Vex.Flow.TextNote.Justification.LEFT)
		)	
	}

	var voice_music = new VF.Voice({num_beats: metas.beat_num ,  beat_value: metas.beat_value})
	var voice_text  = new VF.Voice({num_beats: metas.beat_num ,  beat_value: metas.beat_value})
	voice_music.addTickables(notes_to_render)
	voice_text .addTickables(texts_to_render)

	var formatter = new VF.Formatter().joinVoices([voice_music , voice_text])
	formatter.format([voice_music , voice_text], metas.width - 30)
	voice_music.draw(context, stave)	
	voice_text .draw(context, stave)	

	// ---------- 输出 ----------

	element.innerHTML = render_container.innerHTML	
}

function ymusic_parse(){
	var elements = document.getElementsByClassName("YMusic")
	for(var ele of elements){
		var er = ele.attributes
		width 			= er.w 				? parseInt(er.w.value) 		: "auto" // auto: 每个4分音符占50px
		height 			= er.h 				? parseInt(er.h.value) 		: "auto"
		fillcolor 		= er.fillcolor 		? er.fillcolor.value 		: "#000000" //默认黑色
		backfillcolor 	= er.backfillcolor  ? er.backfillcolor.value 	: "#00000000" //默认透明
		topspace 		= er.topspace 		? parseInt(er.topspace.value) : "auto"
		ymusic_draw_music(ele , width , height , fillcolor , backfillcolor)
	}
}

ymusic_parse()

</script>